import Foundation


public enum CodeGeneration {
    public static func generate(fromCollections collections: [UUIDCollection]) -> Result<String, CodeGenerationError> {
        var codes = [String]()
        
        for collection in collections {
            switch generate(fromCollection: collection) {
            case .failure(let error):
                return .failure(error)
            case .success(let code):
                codes.append(code)
            }
        }
        
        return .success("""
/// This file is generated by CodeGenerator.
/// Do not modify this file directly.

import Foundation


public enum AssignedNumbers {
\(codes.joined(separator: "\n\n"))
}

""")
    }
    
    
    public static func generate(fromCollection collection: UUIDCollection) -> Result<String, CodeGenerationError> {
        let basename = collection.url.lastPathComponent
        
        guard basename != "" else {
            return .failure(.emptyPath(url: collection.url))
        }
        
        let basenameWithoutExtension = basename.split(separator: ".", maxSplits: 1).first!
        
        var codes = [String]()
        var propNames  = [String]()
        
        // NOTE: name is not unique.
        var entryGroups = [String: [UUIDCollectionEntry]]()
        for entry in collection.entries {
            let propName = propertyName(of: entry.name)
            if var entries = entryGroups[propName] {
                entries.append(entry)
            } else {
                entryGroups[propName] = [entry]
            }
        }
        
        for entryGroupValues in entryGroups.sorted(by: { (t1, t2) in t1.key < t2.key}).map(\.value) {
            let shouldAppendIndex = entryGroupValues.count > 1
            
            for (index, entry) in entryGroupValues.enumerated() {
                let propName = shouldAppendIndex ? propertyName(of: entry.name) + String(index) : propertyName(of: entry.name) 
                propNames.append(propName)
                
                if let id = entry.id {
                    codes.append("""
        /// \(entry.name). ID is `\(id)`.
        public static let \(propName) = AssignedNumberWithID(
            name: \(NameNormalization.escapeDoubleQuotes(entry.name)),
            id: "\(id)",
            uuidByte3: 0x\(String(entry.uuidByte3, radix: 16, uppercase: false)),
            uuidByte4: 0x\(String(entry.uuidByte4, radix: 16, uppercase: false))
        )
""")
                } else {
                    codes.append("""
        /// \(entry.name).
        public static let \(propName) = AssignedNumberWithoutID(
            name: \(NameNormalization.escapeDoubleQuotes(entry.name)),
            uuidByte3: 0x\(String(entry.uuidByte3, radix: 16, uppercase: false)),
            uuidByte4: 0x\(String(entry.uuidByte4, radix: 16, uppercase: false))
        )
""")
                }
            }
        }
        
        return .success("""
    /// From `\(collection.url.relativePath)`.
    public enum \(NameNormalization.upperCamelCase(words: basenameWithoutExtension.split(separator: "_"))) {
\(codes.joined(separator: "\n\n"))

        public static let all: [any AssignedNumberProtocol] = [
\(propNames.map { "            \($0)," }.joined(separator: "\n"))
        ]
    }
""")
    }
    
    
    private static func propertyName(of unsafeName: String) -> String {
        let alphaNumericsSplittedBySpaces = unsafeName.unicodeScalars.filter{ CharacterSet.alphanumerics.contains(_: $0) || $0 == " " }
        
        let startsWithDigit = CharacterSet.decimalDigits.contains(alphaNumericsSplittedBySpaces.first!)
        return NameNormalization.lowerCamelCase(words: (startsWithDigit ? "_\(alphaNumericsSplittedBySpaces)" : String(alphaNumericsSplittedBySpaces)).split(separator: " "))
    }
}
